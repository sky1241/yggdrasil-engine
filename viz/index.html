<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>YGGDRASIL â€” La Pluie</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #080810; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
canvas { display: block; position: fixed; top: 0; left: 0; }

#title-bar {
  position: fixed; top: 12px; left: 15px; z-index: 10;
  font-size: 11px; max-width: 500px;
}
#title-bar h2 { color: #4ade80; font-size: 16px; letter-spacing: 2px; }
#title-bar .stats { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-top: 2px; }
#title-bar .sub { color: #444; font-size: 9px; margin-top: 1px; }

#legend {
  position: fixed; top: 15px; right: 15px; z-index: 10;
  font-size: 10px;
}
.legend-row { display: flex; align-items: center; margin: 3px 0; cursor: default; }
.legend-dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; flex-shrink: 0; }
.legend-label { color: #666; }
.legend-count { color: #444; margin-left: 6px; }
.legend-sep { border-top: 1px solid #333; margin: 6px 0; }

#hover-info {
  position: fixed; bottom: 60px; left: 15px; z-index: 10;
  background: rgba(0,0,0,0.88); padding: 12px 18px; border-left: 3px solid #f90;
  font-size: 11px; display: none; max-width: 400px;
}
#hover-info .strate-name { font-size: 14px; font-weight: bold; margin-bottom: 4px; }
#hover-info .strate-desc { color: #888; font-size: 10px; margin-bottom: 4px; }
#hover-info .sym-char { font-size: 28px; margin-right: 8px; vertical-align: middle; }
#hover-info .sym-name { color: #ccc; }
#hover-info .sym-domain { color: #666; font-size: 10px; }
#hover-info .sym-meta { color: #444; font-size: 9px; margin-top: 4px; }
#hover-info .continent-tag {
  display: inline-block; padding: 1px 6px; border-radius: 3px;
  font-size: 9px; margin-top: 4px;
}

#bottom-bar {
  position: fixed; bottom: 0; left: 0; right: 0; z-index: 10;
  background: rgba(0,0,0,0.7); padding: 6px 15px;
  font-size: 9px; color: #444; display: flex; justify-content: space-between;
  border-top: 1px solid #1a1a2e;
}

#controls {
  position: fixed; bottom: 40px; right: 15px; z-index: 10;
  font-size: 9px;
}
#controls label { color: #555; display: block; margin: 2px 0; }
#controls input[type=range] { width: 100px; vertical-align: middle; }
#controls input[type=checkbox] { vertical-align: middle; }
#controls .color-mode { margin-top: 6px; padding-top: 6px; border-top: 1px solid #333; }
#controls .color-mode span { color: #888; font-size: 10px; }
#controls .mode-btn {
  background: none; border: 1px solid #444; color: #888; padding: 2px 8px;
  font-family: 'Courier New', monospace; font-size: 9px; cursor: pointer; margin: 2px 2px;
}
#controls .mode-btn.active { border-color: #4ade80; color: #4ade80; }
#controls .mode-btn:hover { border-color: #666; color: #aaa; }

#strate-indicator {
  position: fixed; top: 15px; right: 220px; z-index: 10;
  font-size: 10px; color: #555; text-align: right;
}
</style>
</head>
<body>

<div id="title-bar">
  <h2>Yggdrasil &middot; La Pluie</h2>
  <div class="stats"></div>
  <div class="sub">Post 1944 &times; Science of Science &times; Lianes &times; MÃ©tÃ©orites</div>
</div>

<div id="strate-indicator"></div>
<div id="legend"></div>

<div id="hover-info">
  <div class="strate-name"></div>
  <div class="strate-desc"></div>
  <hr style="border:none;border-top:1px solid #333;margin:6px 0">
  <span class="sym-char"></span>
  <span class="sym-name"></span><br>
  <span class="sym-domain"></span>
  <div class="sym-meta"></div>
  <div class="continent-tag"></div>
</div>

<div id="controls">
  <label>Rotation: <input type="range" id="speed" min="0" max="100" value="20"></label>
  <label>Taille: <input type="range" id="symsize" min="1" max="30" value="12"></label>
  <label><input type="checkbox" id="showPlanes" checked> Plans strates</label>
  
  <label><input type="checkbox" id="showOxygen" checked onchange="showOxygen=this.checked"> OxygÃ¨ne (=â†’tous)</label>
  <label><input type="checkbox" id="showLianeVert" checked onchange="showLianes=this.checked"> Lianes verticales</label>
  <label><input type="checkbox" id="showMeteor" onchange="showMeteors=this.checked"> ğŸ’¥ MÃ©tÃ©orites S3â†’S0</label>

  <label><input type="checkbox" id="showLabels" checked> Labels centres</label>
  <div class="color-mode">
    <span>Couleur:</span><br>
    <button class="mode-btn active" id="modeStrate" onclick="setColorMode('strate')">Strate</button>
    <button class="mode-btn" id="modeContinent" onclick="setColorMode('continent')">Continent</button>
  </div>
</div>

<div id="bottom-bar">
  <span id="bb-left">0x0f</span>
  <span id="bb-center">structuree directement exploitable</span>
  <span id="bb-right"></span>
</div>

<script src="three.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YGGDRASIL Â· LA PLUIE â€” 794 symboles en orbites spectrales
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if (typeof THREE === 'undefined') {
  document.body.innerHTML = '<div style="color:red;padding:40px;font-size:18px">Three.js failed to load.</div>';
}

const STRATE_COLORS = [
  [74, 222, 128],   // S0 SOL
  [96, 165, 250],   // S1 HALTING
  [167, 139, 250],  // S2 LIMITE
  [244, 114, 182],  // S3 MOTIF
  [251, 191, 36],   // S4 CIEL
  [251, 146, 60],   // S5 HYP
  [239, 68, 68],    // S6 PLAFOND
];

const CONTINENT_COLORS = [
  [30, 58, 138],    // Maths Pures â€” bleu fonce
  [124, 58, 237],   // Physique â€” violet
  [234, 88, 12],    // Ingenierie â€” orange
  [6, 182, 212],    // Info & IA â€” cyan
  [234, 179, 8],    // Finance â€” jaune
  [132, 204, 22],   // Bio & Med â€” vert lime
  [244, 63, 94],    // Chimie â€” rouge clair
];

const CONTINENT_NAMES = [
  "Maths Pures", "Physique", "Ingenierie",
  "Info & IA", "Finance", "Bio & Med", "Chimie"
];


// â”€â”€ LIANES â€” symbols crossing multiple continents â”€â”€
const LIANES = {
  "=":7,"exp":6,"ln":6,"Î£":6,"âˆ«":6,"e":5,"âˆ‚":5,
  "Bayes":4,"E[X]":4,"FFT":4,"N(Î¼,ÏƒÂ²)":4,"O(n)":4,"P(A)":4,"Var":4,
  "cos":4,"d/dx":4,"det":4,"lim":4,"log":4,"sin":4,"Î ":4,"Î´":4,"Îµ":4,
  "Î»":4,"Ï€":4,"Ïƒ_std":4,"Ï‡Â²":4,"â„±":4,"âˆ‡":4,"âˆ‡Â²":4,"âˆ¬":4,"âˆ®":4,"âˆ—_conv":4,
  "Attn":3,"BS":3,"D_KL":3,"F=ma":3,"GAN":3,"H(X)":3,"ItÃ´":3,"Nash":3,
  "PV=nRT":3,"Re":3,"Râ‚€":3,"SDE":3,"SGD":3,"S_ent":3,"TM":3,"W(t)":3,
  "argmax":3,"argmin":3,"i":3,"Î“":3,"Î¶":3,"â„‹":3,"â„’":3,"âˆ‡L":3,"âˆ‡Â·":3,"âˆ‡Ã—":3,
};

const GRAVITY = {
  "exp":168,"âˆ«":90,"Î£":84,"âˆ‚":50,"log":40,"P(A)":36,
  "âˆ‡Â²":28,"Î»":24,"det":20,"sin":20,"cos":20,"Ï€":16,"Bayes":16,"E[X]":16,
  "âˆ‡L":15,"Râ‚€":15,"lim":12,"argmin":12,"â„±":12,"FFT":12,
  "â„’":9,"âˆ—_conv":8,"âˆ‡":8,"Ï‡Â²":8,"Var":8,"Îµ":8,
  "S_ent":6,"Î“":6,"H(X)":6,"Attn":6,"O(n)":4,"Î´":4,"N(Î¼,ÏƒÂ²)":4,
  "Î¶":3,"SGD":3,"i":3,"PV=nRT":3,"Re":3,"D_KL":3,"argmax":3,"Nash":3,"GAN":3,
};

const METEORS = [
  {n:"Fermat",p:"âˆ«",s:"Î£"},{n:"PoincarÃ©",p:"exp",s:"S_ent"},
  {n:"Higgs",p:"exp",s:"âˆ«"},{n:"Deep Learning",p:"exp",s:"Î£"},
  {n:"AlphaFold",p:"exp",s:"Attn"},{n:"GANs",p:"exp",s:"Nash"},
  {n:"Transformer",p:"exp",s:"Î£"},{n:"Black-Scholes",p:"âˆ‚",s:"W(t)"},
  {n:"mRNA",p:"exp",s:"P(A)"},{n:"ImmunothÃ©rapie",p:"exp",s:"Râ‚€"},
  {n:"Ondes grav.",p:"exp",s:"FFT"},{n:"Blockchain",p:"exp",s:"H(X)"},
  {n:"Cryo-EM",p:"âˆ«",s:"FFT"},{n:"CAR-T",p:"exp",s:"Î£"},
  {n:"Perovskite",p:"exp",s:"âˆ«"},{n:"OptogÃ©nÃ©tique",p:"exp",s:"Î»"},
];

let oxygenLines = [];
let lianeVerticals = [];
let meteorTrails = [];
let showOxygen = true;
let showLianes = true;
let showMeteors = false;

const STRATE_SHORT = ["SOL", "K", "FIN", "COF", "Th(N)", "O_KiL", "HALT"];

let scene, camera, renderer, cubeGroup;
let symbolMeshes = [];
let planesMeshes = [];
let centerLabels = [];
let mouse = new THREE.Vector2(-9, -9);
let raycaster = new THREE.Raycaster();
let data = null;
let time = 0;
let textureCache = {};
let colorMode = 'strate'; // 'strate' or 'continent'

// â”€â”€ Color mode toggle â”€â”€
function setColorMode(mode) {
  colorMode = mode;
  document.getElementById('modeStrate').classList.toggle('active', mode === 'strate');
  document.getElementById('modeContinent').classList.toggle('active', mode === 'continent');

  // Rebuild all symbol sprites with new colors
  symbolMeshes.forEach((sprite, i) => {
    const sym = data.symbols[i];
    const rgb = getSymbolColor(sym);
    const tex = makeSymbolTexture(sym.s, rgb, sym.is_center);
    sprite.material.map = tex;
    sprite.material.needsUpdate = true;
  });

  buildLegend(data);
}

function getSymbolColor(sym) {
  if (colorMode === 'continent' && sym.continent >= 0) {
    return CONTINENT_COLORS[sym.continent];
  }
  return STRATE_COLORS[sym.strate];
}

async function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x080810);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(5, 3.5, 5);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  const resp = await fetch('data.json');
  if (!resp.ok) { document.body.innerHTML = '<div style="color:red;padding:40px">FETCH FAILED</div>'; return; }
  data = await resp.json();

  buildStrates(data);
  buildSymbols(data);
  buildWireframe();
  buildOxygen(data);
  buildLianeVerticals(data);
  buildMeteorTrails(data);
  buildLegend(data);
  updateUI(data);

  scene.add(new THREE.AmbientLight(0xffffff, 0.3));

  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('mousemove', onMouseMove);

  animate();
}

// â”€â”€ Build strate planes â”€â”€
function buildStrates(data) {
  data.strates.forEach((strate, i) => {
    const y = strate.y;
    const c = STRATE_COLORS[i];
    const color = new THREE.Color(c[0]/255, c[1]/255, c[2]/255);

    const geo = new THREE.PlaneGeometry(3.4, 3.4);
    const mat = new THREE.MeshBasicMaterial({
      color: color, transparent: true, opacity: 0.08 + (i * 0.01),
      side: THREE.DoubleSide, depthWrite: false,
    });
    const plane = new THREE.Mesh(geo, mat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = y;
    cubeGroup.add(plane);
    planesMeshes.push(plane);

    // Grid
    const gridGeo = new THREE.PlaneGeometry(3.4, 3.4, 8, 8);
    const gridMat = new THREE.MeshBasicMaterial({
      color: color, transparent: true, opacity: 0.04, wireframe: true, depthWrite: false,
    });
    const grid = new THREE.Mesh(gridGeo, gridMat);
    grid.rotation.x = -Math.PI / 2;
    grid.position.y = y;
    cubeGroup.add(grid);
    planesMeshes.push(grid);

    // Border
    const edges = new THREE.EdgesGeometry(geo);
    const borderMat = new THREE.LineBasicMaterial({ color: color, opacity: 0.35, transparent: true });
    const border = new THREE.LineSegments(edges, borderMat);
    border.rotation.x = -Math.PI / 2;
    border.position.y = y;
    cubeGroup.add(border);
    planesMeshes.push(border);

    // Center label
    const label = makeTextSprite(STRATE_SHORT[i], c, 0.5);
    label.position.set(0, y + 0.01, 0);
    cubeGroup.add(label);
    centerLabels.push(label);
  });
}

// â”€â”€ Build symbols as TEXT sprites â”€â”€
function buildSymbols(data) {
  data.symbols.forEach((sym) => {
    const rgb = getSymbolColor(sym);
    const strateData = data.strates[sym.strate];
    const y = strateData.y;

    const x = (sym.px || (Math.random() * 2 - 1)) * 1.4;
    const z = (sym.pz || (Math.random() * 2 - 1)) * 1.4;

    const tex = makeSymbolTexture(sym.s, rgb, sym.is_center);
    const mat = new THREE.SpriteMaterial({
      map: tex, transparent: true, depthWrite: false,
      opacity: sym.is_center ? 1.0 : 0.85,
    });
    const sprite = new THREE.Sprite(mat);
    sprite.position.set(x, y + (Math.random() - 0.5) * 0.02, z);

    const baseScale = sym.is_center ? 0.22 : 0.09;
    sprite.scale.set(baseScale, baseScale, 1);

    sprite.userData = {
      symbol: sym.s,
      from: sym.from,
      domain: sym.domain,
      strate: sym.strate,
      continent: sym.continent,
      strateName: strateData.name,
      isCenter: sym.is_center,
      baseScale: baseScale,
      baseY: y,
      orbitRadius: Math.sqrt(x*x + z*z),
      orbitAngle: Math.atan2(z, x),
      orbitSpeed: 0.05 + Math.random() * 0.15,
    };

    cubeGroup.add(sprite);
    symbolMeshes.push(sprite);
  });
}

// â”€â”€ Create texture for a symbol character â”€â”€
function makeSymbolTexture(char, rgb, isCenter) {
  const key = char + '_' + rgb.join(',') + '_' + isCenter;
  if (textureCache[key]) return textureCache[key];

  const size = 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const r = rgb[0], g = rgb[1], b = rgb[2];

  if (isCenter) {
    const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    grad.addColorStop(0, `rgba(${r},${g},${b},0.4)`);
    grad.addColorStop(0.5, `rgba(${r},${g},${b},0.1)`);
    grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
  }

  ctx.font = isCenter ? 'bold 64px Courier New' : '48px Courier New';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = `rgb(${r},${g},${b})`;
  ctx.shadowBlur = isCenter ? 25 : 12;
  ctx.fillStyle = `rgba(${r},${g},${b},${isCenter ? 1.0 : 0.9})`;
  ctx.fillText(char, size/2, size/2);
  ctx.shadowBlur = isCenter ? 15 : 6;
  ctx.fillText(char, size/2, size/2);

  const tex = new THREE.CanvasTexture(canvas);
  textureCache[key] = tex;
  return tex;
}

// â”€â”€ Center label sprite â”€â”€
function makeTextSprite(text, rgb, scale) {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  const r = rgb[0], g = rgb[1], b = rgb[2];

  ctx.font = 'bold 90px Courier New';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = `rgb(${r},${g},${b})`;
  ctx.shadowBlur = 40;
  ctx.fillStyle = `rgba(${r},${g},${b},0.9)`;
  ctx.fillText(text, 256, 128);
  ctx.shadowBlur = 20;
  ctx.fillText(text, 256, 128);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(scale * 2, scale, 1);
  return sprite;
}


// â”€â”€ OXYGEN: every S0 symbol connected to = â”€â”€
function buildOxygen(data) {
  // Find = position
  const eqSym = data.symbols.find(s => s.s === '=');
  if (!eqSym) return;
  const eqStrate = data.strates[eqSym.strate];
  const eqY = eqStrate.y;
  const eqX = (eqSym.px || 0) * 1.4;
  const eqZ = (eqSym.pz || 0) * 1.4;

  const s0Symbols = data.symbols.filter(s => s.strate === 0 && s.s !== '=');
  
  s0Symbols.forEach(sym => {
    const sx = (sym.px || 0) * 1.4;
    const sz = (sym.pz || 0) * 1.4;
    const isLiane = sym.s in LIANES;
    const lc = LIANES[sym.s] || 0;
    
    // Opacity: lianes stronger, capitals fainter
    let opacity = 0.02; // baseline: everyone breathes oxygen
    if (lc >= 6) opacity = 0.15;
    else if (lc >= 4) opacity = 0.08;
    else if (lc >= 3) opacity = 0.05;
    
    const color = isLiane ? 0xffd700 : 0x4ade80;
    
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(sx, eqY, sz),
      new THREE.Vector3(eqX, eqY, eqZ),
    ]);
    const mat = new THREE.LineBasicMaterial({
      color: color, transparent: true, opacity: opacity, depthWrite: false,
    });
    const line = new THREE.Line(geo, mat);
    cubeGroup.add(line);
    oxygenLines.push(line);
  });
}

// â”€â”€ LIANE VERTICALS: escaliers S0 â†’ strates supÃ©rieures â”€â”€
function buildLianeVerticals(data) {
  const lianeSymbols = data.symbols.filter(s => s.strate === 0 && s.s in LIANES && s.s !== '=');
  
  lianeSymbols.forEach(sym => {
    const sx = (sym.px || 0) * 1.4;
    const sz = (sym.pz || 0) * 1.4;
    const lc = LIANES[sym.s] || 0;
    const grav = GRAVITY[sym.s] || 0;
    
    // How high does this liane reach?
    // Higher gravity = reaches higher strates
    let maxStrateIdx = 1; // at least S1
    if (grav >= 80) maxStrateIdx = 5;  // soleils reach near top
    else if (grav >= 30) maxStrateIdx = 4;
    else if (grav >= 10) maxStrateIdx = 3;
    else if (grav >= 3) maxStrateIdx = 2;
    
    const s0y = data.strates[0].y;
    const topY = data.strates[Math.min(maxStrateIdx, data.strates.length - 1)].y;
    
    // Build vertical line with segments
    const points = [];
    const steps = 20;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      // Slight spiral as it goes up
      const angle = t * Math.PI * 0.5;
      const drift = 0.05 * Math.sin(angle * 3);
      points.push(new THREE.Vector3(
        sx + drift,
        s0y + (topY - s0y) * t,
        sz + drift
      ));
    }
    
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    
    // Color: gold for big lianes, dimmer for small
    let opacity = 0.08 + (lc / 7) * 0.2;
    let color = grav >= 80 ? 0xffaa00 : grav >= 30 ? 0xffd700 : 0x88aaff;
    
    const mat = new THREE.LineBasicMaterial({
      color: color, transparent: true, opacity: opacity, depthWrite: false,
    });
    const line = new THREE.Line(geo, mat);
    cubeGroup.add(line);
    lianeVerticals.push({ line, sym: sym.s, grav, maxStrate: maxStrateIdx });
    
    // Small glow at the top endpoint
    if (grav >= 30) {
      const dotGeo = new THREE.SphereGeometry(0.015, 8, 6);
      const dotMat = new THREE.MeshBasicMaterial({
        color: color, transparent: true, opacity: opacity * 1.5,
      });
      const dot = new THREE.Mesh(dotGeo, dotMat);
      dot.position.set(sx, topY, sz);
      cubeGroup.add(dot);
    }
  });
}

// â”€â”€ METEOR TRAILS: S3 discoveries falling to S0 â”€â”€
function buildMeteorTrails(data) {
  const s3y = data.strates[3] ? data.strates[3].y : 0;
  const s0y = data.strates[0].y;
  
  METEORS.forEach((m, mi) => {
    const target = data.symbols.find(s => s.s === m.p && s.strate === 0);
    if (!target) return;
    
    const tx = (target.px || 0) * 1.4;
    const tz = (target.pz || 0) * 1.4;
    
    // Start from above S3, slightly offset
    const startX = tx + (Math.sin(mi * 2.1)) * 0.3;
    const startZ = tz + (Math.cos(mi * 1.7)) * 0.3;
    const startY = s3y + 0.3;
    
    const points = [];
    const steps = 30;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      // Curved descent
      points.push(new THREE.Vector3(
        startX + (tx - startX) * t,
        startY + (s0y - startY) * t * t, // parabolic
        startZ + (tz - startZ) * t,
      ));
    }
    
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({
      color: 0xff4444, transparent: true, opacity: 0, depthWrite: false,
    });
    const line = new THREE.Line(geo, mat);
    cubeGroup.add(line);
    
    // Impact glow at S0
    const glowGeo = new THREE.SphereGeometry(0.04, 12, 8);
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0xff4444, transparent: true, opacity: 0,
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    glow.position.set(tx, s0y, tz);
    cubeGroup.add(glow);
    
    meteorTrails.push({ line, glow, name: m.n, sym: m.p });
  });
}


// â”€â”€ Wireframe cube â”€â”€
function buildWireframe() {
  const geo = new THREE.BoxGeometry(3.6, 2.8, 3.6);
  const edges = new THREE.EdgesGeometry(geo);
  const mat = new THREE.LineBasicMaterial({ color: 0x4ade80, opacity: 0.15, transparent: true });
  const line = new THREE.LineSegments(edges, mat);
  line.position.y = -0.2;
  cubeGroup.add(line);

  const axisGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, -1.6, 0),
    new THREE.Vector3(0, 1.2, 0)
  ]);
  const axisMat = new THREE.LineBasicMaterial({ color: 0x4ade80, opacity: 0.1, transparent: true });
  cubeGroup.add(new THREE.Line(axisGeo, axisMat));
}

// â”€â”€ Legend (switches between strate and continent) â”€â”€
function buildLegend(data) {
  const el = document.getElementById('legend');
  let html = '';

  if (colorMode === 'strate') {
    data.strates.forEach((s, i) => {
      const c = STRATE_COLORS[i];
      html += `<div class="legend-row">
        <div class="legend-dot" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>
        <span class="legend-label">S${i} ${STRATE_SHORT[i]}</span>
        <span class="legend-count">${s.count}</span>
      </div>`;
    });
  } else {
    // Count symbols per continent
    const counts = new Array(7).fill(0);
    data.symbols.forEach(s => { if (s.continent >= 0) counts[s.continent]++; });
    const unclassified = data.symbols.filter(s => s.continent < 0).length;

    CONTINENT_NAMES.forEach((name, i) => {
      const c = CONTINENT_COLORS[i];
      html += `<div class="legend-row">
        <div class="legend-dot" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>
        <span class="legend-label">${name}</span>
        <span class="legend-count">${counts[i]}</span>
      </div>`;
    });
    if (unclassified > 0) {
      html += `<div class="legend-row">
        <div class="legend-dot" style="background:#555"></div>
        <span class="legend-label">Non classe</span>
        <span class="legend-count">${unclassified}</span>
      </div>`;
    }
  }
  el.innerHTML = html;
}

function updateUI(data) {
  const total = data.meta.total;
  const domains = [...new Set(data.symbols.map(s => s.domain))].length;
  document.querySelector('#title-bar .stats').textContent =
    `${total} SYMBOLES \u00B7 ${domains} DOMAINES \u00B7 ORBITES SPECTRALES`;

  const now = new Date();
  document.getElementById('bb-right').textContent =
    `${now.toLocaleDateString('fr-FR')} \u00B7 ${total} sym`;
  document.getElementById('strate-indicator').textContent = 'PLAFOND \u2192 HALT';
}

// â”€â”€ Animation â”€â”€
function animate() {
  requestAnimationFrame(animate);
  time += 0.016;

  const speed = document.getElementById('speed').value / 5000;
  const symSize = document.getElementById('symsize').value / 10;
  const showPlanes = document.getElementById('showPlanes').checked;
  const showLabels = document.getElementById('showLabels').checked;

  cubeGroup.rotation.y += speed;
  camera.position.y = 3.5 + Math.sin(time * 0.2) * 0.3;
  camera.lookAt(0, -0.2, 0);

  symbolMeshes.forEach(sprite => {
    const ud = sprite.userData;
    if (!ud.isCenter && ud.orbitRadius > 0.1) {
      const angle = ud.orbitAngle + time * ud.orbitSpeed * 0.08;
      sprite.position.x = Math.cos(angle) * ud.orbitRadius;
      sprite.position.z = Math.sin(angle) * ud.orbitRadius;
    }
    sprite.position.y = ud.baseY + Math.sin(time * 0.5 + ud.orbitAngle) * 0.015;
    const s = ud.baseScale * symSize;
    sprite.scale.set(s, s, 1);
  });

  planesMeshes.forEach(p => p.visible = showPlanes);
  centerLabels.forEach(l => l.visible = showLabels);


  // Oxygen lines visibility
  oxygenLines.forEach(l => l.visible = showOxygen && showPlanes);
  
  // Liane verticals: gentle pulse
  lianeVerticals.forEach((lv, i) => {
    lv.line.visible = showLianes;
    if (showLianes) {
      const pulse = 0.7 + 0.3 * Math.sin(time * 1.5 + i * 0.5);
      lv.line.material.opacity = (0.08 + (lv.grav / 168) * 0.2) * pulse;
    }
  });
  
  // Meteor trails: animate
  meteorTrails.forEach((mt, i) => {
    mt.line.visible = showMeteors;
    mt.glow.visible = showMeteors;
    if (showMeteors) {
      const pulse = 0.3 + 0.4 * Math.sin(time * 3 + i * 0.7);
      mt.line.material.opacity = pulse;
      mt.glow.material.opacity = pulse * 0.8;
      mt.glow.scale.setScalar(1 + 0.3 * Math.sin(time * 4 + i));
    }
  });

  // Raycast hover
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(symbolMeshes);
  const hoverEl = document.getElementById('hover-info');

  if (intersects.length > 0) {
    const ud = intersects[0].object.userData;
    if (ud.symbol) {
      const sc = STRATE_COLORS[ud.strate];
      const srgb = `rgb(${sc[0]},${sc[1]},${sc[2]})`;
      hoverEl.querySelector('.strate-name').textContent = ud.strateName;
      hoverEl.querySelector('.strate-name').style.color = srgb;
      hoverEl.querySelector('.strate-desc').textContent =
        `S${ud.strate} \u00B7 ${data.strates[ud.strate].count} symboles`;
      hoverEl.querySelector('.sym-char').textContent = ud.symbol;
      hoverEl.querySelector('.sym-char').style.color = srgb;
      hoverEl.querySelector('.sym-name').textContent = ud.from;
      hoverEl.querySelector('.sym-domain').textContent = ud.domain;
      hoverEl.querySelector('.sym-meta').textContent =
        `strate ${ud.strate} \u00B7 ${ud.isCenter ? 'CENTRE' : 'symbole'}`;


      // Liane & gravity info
      const lianeInfo = LIANES[ud.symbol];
      const gravInfo = GRAVITY[ud.symbol];
      let extraMeta = '';
      if (lianeInfo) extraMeta += ` Â· ğŸŒ¿ LIANE ${lianeInfo} continents`;
      if (gravInfo) extraMeta += ` Â· gravitÃ© ${gravInfo}`;
      const meteorHits = METEORS.filter(m => m.p === ud.symbol);
      if (meteorHits.length) extraMeta += ` Â· ğŸ’¥ ${meteorHits.map(m=>m.n).join(', ')}`;
      hoverEl.querySelector('.sym-meta').textContent += extraMeta;

      // Continent tag
      const cTag = hoverEl.querySelector('.continent-tag');
      if (ud.continent >= 0) {
        const cc = CONTINENT_COLORS[ud.continent];
        cTag.textContent = CONTINENT_NAMES[ud.continent];
        cTag.style.background = `rgb(${cc[0]},${cc[1]},${cc[2]})`;
        cTag.style.color = '#fff';
        cTag.style.display = 'inline-block';
      } else {
        cTag.style.display = 'none';
      }

      hoverEl.style.display = 'block';
      hoverEl.style.borderColor = srgb;
    }
  } else {
    hoverEl.style.display = 'none';
  }

  renderer.render(scene, camera);
}

function onMouseMove(e) {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

init();
</script>
</body>
</html>
