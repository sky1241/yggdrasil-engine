<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>YGGDRASIL — La Pluie</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #080810; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
canvas { display: block; position: fixed; top: 0; left: 0; }

#title-bar {
  position: fixed; top: 12px; left: 15px; z-index: 10;
  font-size: 11px; max-width: 500px;
}
#title-bar h2 { color: #4ade80; font-size: 16px; letter-spacing: 2px; }
#title-bar .stats { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-top: 2px; }
#title-bar .sub { color: #444; font-size: 9px; margin-top: 1px; }

#legend {
  position: fixed; top: 15px; right: 15px; z-index: 10;
  font-size: 10px;
}
.legend-row { display: flex; align-items: center; margin: 3px 0; cursor: default; }
.legend-dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; flex-shrink: 0; }
.legend-label { color: #666; }
.legend-count { color: #444; margin-left: 6px; }
.legend-sep { border-top: 1px solid #333; margin: 6px 0; }

#hover-info {
  position: fixed; bottom: 60px; left: 15px; z-index: 10;
  background: rgba(0,0,0,0.88); padding: 12px 18px; border-left: 3px solid #f90;
  font-size: 11px; display: none; max-width: 400px;
}
#hover-info .strate-name { font-size: 14px; font-weight: bold; margin-bottom: 4px; }
#hover-info .strate-desc { color: #888; font-size: 10px; margin-bottom: 4px; }
#hover-info .sym-char { font-size: 28px; margin-right: 8px; vertical-align: middle; }
#hover-info .sym-name { color: #ccc; }
#hover-info .sym-domain { color: #666; font-size: 10px; }
#hover-info .sym-meta { color: #444; font-size: 9px; margin-top: 4px; }
#hover-info .continent-tag {
  display: inline-block; padding: 1px 6px; border-radius: 3px;
  font-size: 9px; margin-top: 4px;
}

#bottom-bar {
  position: fixed; bottom: 0; left: 0; right: 0; z-index: 10;
  background: rgba(0,0,0,0.7); padding: 6px 15px;
  font-size: 9px; color: #444; display: flex; justify-content: space-between;
  border-top: 1px solid #1a1a2e;
}

#controls {
  position: fixed; bottom: 40px; right: 15px; z-index: 10;
  font-size: 9px;
}
#controls label { color: #555; display: block; margin: 2px 0; }
#controls input[type=range] { width: 100px; vertical-align: middle; }
#controls input[type=checkbox] { vertical-align: middle; }
#controls .color-mode { margin-top: 6px; padding-top: 6px; border-top: 1px solid #333; }
#controls .color-mode span { color: #888; font-size: 10px; }
#controls .mode-btn {
  background: none; border: 1px solid #444; color: #888; padding: 2px 8px;
  font-family: 'Courier New', monospace; font-size: 9px; cursor: pointer; margin: 2px 2px;
}
#controls .mode-btn.active { border-color: #4ade80; color: #4ade80; }
#controls .mode-btn:hover { border-color: #666; color: #aaa; }

#strate-indicator {
  position: fixed; top: 15px; right: 220px; z-index: 10;
  font-size: 10px; color: #555; text-align: right;
}
</style>
</head>
<body>

<div id="title-bar">
  <h2>Yggdrasil &middot; La Pluie</h2>
  <div class="stats"></div>
  <div class="sub">Hierarchie arithmetique (Post 1944) &times; Science of Science</div>
</div>

<div id="strate-indicator"></div>
<div id="legend"></div>

<div id="hover-info">
  <div class="strate-name"></div>
  <div class="strate-desc"></div>
  <hr style="border:none;border-top:1px solid #333;margin:6px 0">
  <span class="sym-char"></span>
  <span class="sym-name"></span><br>
  <span class="sym-domain"></span>
  <div class="sym-meta"></div>
  <div class="continent-tag"></div>
</div>

<div id="controls">
  <label>Rotation: <input type="range" id="speed" min="0" max="100" value="20"></label>
  <label>Taille: <input type="range" id="symsize" min="1" max="30" value="12"></label>
  <label><input type="checkbox" id="showPlanes" checked> Plans strates</label>
  <label><input type="checkbox" id="showLabels" checked> Labels centres</label>
  <div class="color-mode">
    <span>Couleur:</span><br>
    <button class="mode-btn active" id="modeStrate" onclick="setColorMode('strate')">Strate</button>
    <button class="mode-btn" id="modeContinent" onclick="setColorMode('continent')">Continent</button>
  </div>
</div>

<div id="bottom-bar">
  <span id="bb-left">0x0f</span>
  <span id="bb-center">structuree directement exploitable</span>
  <span id="bb-right"></span>
</div>

<script src="three.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════════════
// YGGDRASIL · LA PLUIE — 794 symboles en orbites spectrales
// ═══════════════════════════════════════════════════════════════

if (typeof THREE === 'undefined') {
  document.body.innerHTML = '<div style="color:red;padding:40px;font-size:18px">Three.js failed to load.</div>';
}

const STRATE_COLORS = [
  [74, 222, 128],   // S0 SOL
  [96, 165, 250],   // S1 HALTING
  [167, 139, 250],  // S2 LIMITE
  [244, 114, 182],  // S3 MOTIF
  [251, 191, 36],   // S4 CIEL
  [251, 146, 60],   // S5 HYP
  [239, 68, 68],    // S6 PLAFOND
];

const CONTINENT_COLORS = [
  [30, 58, 138],    // Maths Pures — bleu fonce
  [124, 58, 237],   // Physique — violet
  [234, 88, 12],    // Ingenierie — orange
  [6, 182, 212],    // Info & IA — cyan
  [234, 179, 8],    // Finance — jaune
  [132, 204, 22],   // Bio & Med — vert lime
  [244, 63, 94],    // Chimie — rouge clair
];

const CONTINENT_NAMES = [
  "Maths Pures", "Physique", "Ingenierie",
  "Info & IA", "Finance", "Bio & Med", "Chimie"
];

const STRATE_SHORT = ["SOL", "K", "FIN", "COF", "Th(N)", "O_KiL", "HALT"];

let scene, camera, renderer, cubeGroup;
let symbolMeshes = [];
let planesMeshes = [];
let centerLabels = [];
let mouse = new THREE.Vector2(-9, -9);
let raycaster = new THREE.Raycaster();
let data = null;
let time = 0;
let textureCache = {};
let colorMode = 'strate'; // 'strate' or 'continent'

// ── Color mode toggle ──
function setColorMode(mode) {
  colorMode = mode;
  document.getElementById('modeStrate').classList.toggle('active', mode === 'strate');
  document.getElementById('modeContinent').classList.toggle('active', mode === 'continent');

  // Rebuild all symbol sprites with new colors
  symbolMeshes.forEach((sprite, i) => {
    const sym = data.symbols[i];
    const rgb = getSymbolColor(sym);
    const tex = makeSymbolTexture(sym.s, rgb, sym.is_center);
    sprite.material.map = tex;
    sprite.material.needsUpdate = true;
  });

  buildLegend(data);
}

function getSymbolColor(sym) {
  if (colorMode === 'continent' && sym.continent >= 0) {
    return CONTINENT_COLORS[sym.continent];
  }
  return STRATE_COLORS[sym.strate];
}

async function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x080810);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(5, 3.5, 5);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  const resp = await fetch('data.json');
  if (!resp.ok) { document.body.innerHTML = '<div style="color:red;padding:40px">FETCH FAILED</div>'; return; }
  data = await resp.json();

  buildStrates(data);
  buildSymbols(data);
  buildWireframe();
  buildLegend(data);
  updateUI(data);

  scene.add(new THREE.AmbientLight(0xffffff, 0.3));

  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('mousemove', onMouseMove);

  animate();
}

// ── Build strate planes ──
function buildStrates(data) {
  data.strates.forEach((strate, i) => {
    const y = strate.y;
    const c = STRATE_COLORS[i];
    const color = new THREE.Color(c[0]/255, c[1]/255, c[2]/255);

    const geo = new THREE.PlaneGeometry(3.4, 3.4);
    const mat = new THREE.MeshBasicMaterial({
      color: color, transparent: true, opacity: 0.08 + (i * 0.01),
      side: THREE.DoubleSide, depthWrite: false,
    });
    const plane = new THREE.Mesh(geo, mat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = y;
    cubeGroup.add(plane);
    planesMeshes.push(plane);

    // Grid
    const gridGeo = new THREE.PlaneGeometry(3.4, 3.4, 8, 8);
    const gridMat = new THREE.MeshBasicMaterial({
      color: color, transparent: true, opacity: 0.04, wireframe: true, depthWrite: false,
    });
    const grid = new THREE.Mesh(gridGeo, gridMat);
    grid.rotation.x = -Math.PI / 2;
    grid.position.y = y;
    cubeGroup.add(grid);
    planesMeshes.push(grid);

    // Border
    const edges = new THREE.EdgesGeometry(geo);
    const borderMat = new THREE.LineBasicMaterial({ color: color, opacity: 0.35, transparent: true });
    const border = new THREE.LineSegments(edges, borderMat);
    border.rotation.x = -Math.PI / 2;
    border.position.y = y;
    cubeGroup.add(border);
    planesMeshes.push(border);

    // Center label
    const label = makeTextSprite(STRATE_SHORT[i], c, 0.5);
    label.position.set(0, y + 0.01, 0);
    cubeGroup.add(label);
    centerLabels.push(label);
  });
}

// ── Build symbols as TEXT sprites ──
function buildSymbols(data) {
  data.symbols.forEach((sym) => {
    const rgb = getSymbolColor(sym);
    const strateData = data.strates[sym.strate];
    const y = strateData.y;

    const x = (sym.px || (Math.random() * 2 - 1)) * 1.4;
    const z = (sym.pz || (Math.random() * 2 - 1)) * 1.4;

    const tex = makeSymbolTexture(sym.s, rgb, sym.is_center);
    const mat = new THREE.SpriteMaterial({
      map: tex, transparent: true, depthWrite: false,
      opacity: sym.is_center ? 1.0 : 0.85,
    });
    const sprite = new THREE.Sprite(mat);
    sprite.position.set(x, y + (Math.random() - 0.5) * 0.02, z);

    const baseScale = sym.is_center ? 0.22 : 0.09;
    sprite.scale.set(baseScale, baseScale, 1);

    sprite.userData = {
      symbol: sym.s,
      from: sym.from,
      domain: sym.domain,
      strate: sym.strate,
      continent: sym.continent,
      strateName: strateData.name,
      isCenter: sym.is_center,
      baseScale: baseScale,
      baseY: y,
      orbitRadius: Math.sqrt(x*x + z*z),
      orbitAngle: Math.atan2(z, x),
      orbitSpeed: 0.05 + Math.random() * 0.15,
    };

    cubeGroup.add(sprite);
    symbolMeshes.push(sprite);
  });
}

// ── Create texture for a symbol character ──
function makeSymbolTexture(char, rgb, isCenter) {
  const key = char + '_' + rgb.join(',') + '_' + isCenter;
  if (textureCache[key]) return textureCache[key];

  const size = 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const r = rgb[0], g = rgb[1], b = rgb[2];

  if (isCenter) {
    const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    grad.addColorStop(0, `rgba(${r},${g},${b},0.4)`);
    grad.addColorStop(0.5, `rgba(${r},${g},${b},0.1)`);
    grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
  }

  ctx.font = isCenter ? 'bold 64px Courier New' : '48px Courier New';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = `rgb(${r},${g},${b})`;
  ctx.shadowBlur = isCenter ? 25 : 12;
  ctx.fillStyle = `rgba(${r},${g},${b},${isCenter ? 1.0 : 0.9})`;
  ctx.fillText(char, size/2, size/2);
  ctx.shadowBlur = isCenter ? 15 : 6;
  ctx.fillText(char, size/2, size/2);

  const tex = new THREE.CanvasTexture(canvas);
  textureCache[key] = tex;
  return tex;
}

// ── Center label sprite ──
function makeTextSprite(text, rgb, scale) {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  const r = rgb[0], g = rgb[1], b = rgb[2];

  ctx.font = 'bold 90px Courier New';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = `rgb(${r},${g},${b})`;
  ctx.shadowBlur = 40;
  ctx.fillStyle = `rgba(${r},${g},${b},0.9)`;
  ctx.fillText(text, 256, 128);
  ctx.shadowBlur = 20;
  ctx.fillText(text, 256, 128);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(scale * 2, scale, 1);
  return sprite;
}

// ── Wireframe cube ──
function buildWireframe() {
  const geo = new THREE.BoxGeometry(3.6, 2.8, 3.6);
  const edges = new THREE.EdgesGeometry(geo);
  const mat = new THREE.LineBasicMaterial({ color: 0x4ade80, opacity: 0.15, transparent: true });
  const line = new THREE.LineSegments(edges, mat);
  line.position.y = -0.2;
  cubeGroup.add(line);

  const axisGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, -1.6, 0),
    new THREE.Vector3(0, 1.2, 0)
  ]);
  const axisMat = new THREE.LineBasicMaterial({ color: 0x4ade80, opacity: 0.1, transparent: true });
  cubeGroup.add(new THREE.Line(axisGeo, axisMat));
}

// ── Legend (switches between strate and continent) ──
function buildLegend(data) {
  const el = document.getElementById('legend');
  let html = '';

  if (colorMode === 'strate') {
    data.strates.forEach((s, i) => {
      const c = STRATE_COLORS[i];
      html += `<div class="legend-row">
        <div class="legend-dot" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>
        <span class="legend-label">S${i} ${STRATE_SHORT[i]}</span>
        <span class="legend-count">${s.count}</span>
      </div>`;
    });
  } else {
    // Count symbols per continent
    const counts = new Array(7).fill(0);
    data.symbols.forEach(s => { if (s.continent >= 0) counts[s.continent]++; });
    const unclassified = data.symbols.filter(s => s.continent < 0).length;

    CONTINENT_NAMES.forEach((name, i) => {
      const c = CONTINENT_COLORS[i];
      html += `<div class="legend-row">
        <div class="legend-dot" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>
        <span class="legend-label">${name}</span>
        <span class="legend-count">${counts[i]}</span>
      </div>`;
    });
    if (unclassified > 0) {
      html += `<div class="legend-row">
        <div class="legend-dot" style="background:#555"></div>
        <span class="legend-label">Non classe</span>
        <span class="legend-count">${unclassified}</span>
      </div>`;
    }
  }
  el.innerHTML = html;
}

function updateUI(data) {
  const total = data.meta.total;
  const domains = [...new Set(data.symbols.map(s => s.domain))].length;
  document.querySelector('#title-bar .stats').textContent =
    `${total} SYMBOLES \u00B7 ${domains} DOMAINES \u00B7 ORBITES SPECTRALES`;

  const now = new Date();
  document.getElementById('bb-right').textContent =
    `${now.toLocaleDateString('fr-FR')} \u00B7 ${total} sym`;
  document.getElementById('strate-indicator').textContent = 'PLAFOND \u2192 HALT';
}

// ── Animation ──
function animate() {
  requestAnimationFrame(animate);
  time += 0.016;

  const speed = document.getElementById('speed').value / 5000;
  const symSize = document.getElementById('symsize').value / 10;
  const showPlanes = document.getElementById('showPlanes').checked;
  const showLabels = document.getElementById('showLabels').checked;

  cubeGroup.rotation.y += speed;
  camera.position.y = 3.5 + Math.sin(time * 0.2) * 0.3;
  camera.lookAt(0, -0.2, 0);

  symbolMeshes.forEach(sprite => {
    const ud = sprite.userData;
    if (!ud.isCenter && ud.orbitRadius > 0.1) {
      const angle = ud.orbitAngle + time * ud.orbitSpeed * 0.08;
      sprite.position.x = Math.cos(angle) * ud.orbitRadius;
      sprite.position.z = Math.sin(angle) * ud.orbitRadius;
    }
    sprite.position.y = ud.baseY + Math.sin(time * 0.5 + ud.orbitAngle) * 0.015;
    const s = ud.baseScale * symSize;
    sprite.scale.set(s, s, 1);
  });

  planesMeshes.forEach(p => p.visible = showPlanes);
  centerLabels.forEach(l => l.visible = showLabels);

  // Raycast hover
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(symbolMeshes);
  const hoverEl = document.getElementById('hover-info');

  if (intersects.length > 0) {
    const ud = intersects[0].object.userData;
    if (ud.symbol) {
      const sc = STRATE_COLORS[ud.strate];
      const srgb = `rgb(${sc[0]},${sc[1]},${sc[2]})`;
      hoverEl.querySelector('.strate-name').textContent = ud.strateName;
      hoverEl.querySelector('.strate-name').style.color = srgb;
      hoverEl.querySelector('.strate-desc').textContent =
        `S${ud.strate} \u00B7 ${data.strates[ud.strate].count} symboles`;
      hoverEl.querySelector('.sym-char').textContent = ud.symbol;
      hoverEl.querySelector('.sym-char').style.color = srgb;
      hoverEl.querySelector('.sym-name').textContent = ud.from;
      hoverEl.querySelector('.sym-domain').textContent = ud.domain;
      hoverEl.querySelector('.sym-meta').textContent =
        `strate ${ud.strate} \u00B7 ${ud.isCenter ? 'CENTRE' : 'symbole'}`;

      // Continent tag
      const cTag = hoverEl.querySelector('.continent-tag');
      if (ud.continent >= 0) {
        const cc = CONTINENT_COLORS[ud.continent];
        cTag.textContent = CONTINENT_NAMES[ud.continent];
        cTag.style.background = `rgb(${cc[0]},${cc[1]},${cc[2]})`;
        cTag.style.color = '#fff';
        cTag.style.display = 'inline-block';
      } else {
        cTag.style.display = 'none';
      }

      hoverEl.style.display = 'block';
      hoverEl.style.borderColor = srgb;
    }
  } else {
    hoverEl.style.display = 'none';
  }

  renderer.render(scene, camera);
}

function onMouseMove(e) {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

init();
</script>
</body>
</html>
